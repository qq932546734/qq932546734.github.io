<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性代数</title>
      <link href="/2019/09/24/linalg/"/>
      <url>/2019/09/24/linalg/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵与方程组"><a href="#矩阵与方程组" class="headerlink" title="矩阵与方程组"></a>矩阵与方程组</h1><hr><h3 id="严格三角形的方程组"><a href="#严格三角形的方程组" class="headerlink" title="严格三角形的方程组"></a>严格三角形的方程组</h3><p>若方程组中，第k个方程的前k-1个变量的系数均为零，且$x_k(k=1,…, n)$的系数不为零，则称该方程组为严格三角形的。</p><h3 id="增广矩阵"><a href="#增广矩阵" class="headerlink" title="增广矩阵"></a>增广矩阵</h3><p>在方程组的系数矩阵的右侧添加一列方程组的右端项，得到增广矩阵</p><h3 id="初等行运算"><a href="#初等行运算" class="headerlink" title="初等行运算"></a>初等行运算</h3><ol><li>交换两行</li><li>以非零实数乘于某行</li><li>将某行替换成它与其他某行的倍数的和</li></ol><h3 id="行阶梯形矩阵"><a href="#行阶梯形矩阵" class="headerlink" title="行阶梯形矩阵"></a>行阶梯形矩阵</h3><p>若一个矩阵满足：</p><ol><li>第一个非零行中的第一个非零元为1；</li><li>第$k$行的元不全为零，第$k+1$行首变量之前零的个数多于第k行首变量之前零的个数；</li><li>所有元素均为零的行必在不全为零的行之后。</li></ol><h3 id="超定方程组"><a href="#超定方程组" class="headerlink" title="超定方程组"></a>超定方程组</h3><p>若一个线性方程组中方程的个数多于未知量的个数，称之为超定方程组。通常为不相容的。</p><h3 id="亚定方程组"><a href="#亚定方程组" class="headerlink" title="亚定方程组"></a>亚定方程组</h3><p>若一个线性方程组中方程的个数少于未知量的个数，称之为亚定方程组。通常为相容的（存在不相容的情况），且如果相容的话，必有无穷组解。</p><h3 id="行最简形矩阵"><a href="#行最简形矩阵" class="headerlink" title="行最简形矩阵"></a>行最简形矩阵</h3><p>矩阵是行阶梯形的，且每一行的第一个非零元是该列唯一的非零行。</p><h3 id="求解线性方程组的方法"><a href="#求解线性方程组的方法" class="headerlink" title="求解线性方程组的方法"></a>求解线性方程组的方法</h3><ul><li>回代法</li><li>高斯消元法：利用初等行运算将线性方程组的增广矩阵化为<strong>行阶梯形矩阵</strong></li><li>高斯-若尔当消元法：采用初等行运算将线性方程组的增广矩阵化成<strong>行最简形</strong></li></ul><h3 id="齐次方程组"><a href="#齐次方程组" class="headerlink" title="齐次方程组"></a>齐次方程组</h3><p><s>右端项全为零的线性方程组。齐次方程组必有平凡解，即所有变量都为零。若齐次方程组为亚定方程组，即方程个数小于变量的个数，该方程组必有非平凡解。</s></p><h3 id="线性方程组相容"><a href="#线性方程组相容" class="headerlink" title="线性方程组相容"></a>线性方程组相容</h3><p>一个线性方程组 $A\textbf{x}=\textbf{b}$ 相容的充要条件是向量$b$可写成矩阵A列向量的一个线性组合。</p><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>若满足$A=A^T$,为对称矩阵</p><h3 id="矩阵的逆、非奇异矩阵"><a href="#矩阵的逆、非奇异矩阵" class="headerlink" title="矩阵的逆、非奇异矩阵"></a>矩阵的逆、非奇异矩阵</h3><p>若存在一个矩阵$B$使得$AB=BA=I$, 则称$n*n$矩阵A为可逆的，也为非奇异的。若矩阵不存在乘法逆元，则称之为奇异的。</p><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><ol><li>$(AB)^T = {B^T}{A^T}$</li></ol><h3 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h3><p>从单位矩阵经过一次初等行运算，得到的矩阵为初等矩阵。初等矩阵分为三类：</p><ol><li>交换单位矩阵的两行，逆运算为本身</li><li>单位矩阵的某一行乘以一个非零常数a，逆运算等于乘以1/a</li><li>单位矩阵的某一行的倍数加到另外一行，逆运算等于减去该倍数  </li></ol><p>矩阵$A$左乘初等矩阵$E_1$(即$E_1*A$)等于将矩阵$A$按照初等矩阵$E_1$进行行变换。右乘等于进行相应的列变换。</p><h3 id="行等价"><a href="#行等价" class="headerlink" title="行等价"></a>行等价</h3><p>若存在一个有限初等矩阵序列$E_1, E_2, E_3, …, E_k$， 使得 $B = E_kE_{k-1}…E_1A$，则称A和B是行等价的。</p><h3 id="非奇异矩阵的等价条件"><a href="#非奇异矩阵的等价条件" class="headerlink" title="非奇异矩阵的等价条件"></a>非奇异矩阵的等价条件</h3><ol><li>$A$是非奇异的</li><li>$Ax=0$仅有平凡解$0$</li><li>$A$与$I$行等价</li></ol><h3 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h3><p>将矩阵A与单位矩阵构成增广矩阵，然后用高斯消元法将A化成单位矩阵，右侧的结果便是$A^{-1}$</p><h3 id="LU分解、三角形分解"><a href="#LU分解、三角形分解" class="headerlink" title="LU分解、三角形分解"></a>LU分解、三角形分解</h3><p>如果一个$n*n$矩阵A可以仅利用初等矩阵运算三（某一行的倍数加到另一行）化简为严格的上三角形的，则A有一个$LU$分解。$U$为严格的上三角形矩阵。<br>$L$为单位下三角矩阵（对角元素为1），且当$i&gt;j$，$L_{ij}$为消元过程中第$i$行减去第$j$行的倍数。</p><h3 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h3><p>不同于内积$x^Ty$，外积等于$xy^T$<br>$$ xy^T = \begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_n \\ \end{bmatrix}<br>(y_1, y_2, …, y_n) $$</p><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><hr><h3 id="子式和余子式"><a href="#子式和余子式" class="headerlink" title="子式和余子式"></a>子式和余子式</h3><p>令$A=(a_{ij})$为一$n*n$矩阵，并用$M_{ij}$来表示删除A中包含$a_{ij}$的行和列得到的$(n-1)(n-1)$矩阵。矩阵$M_{ij}$的行列式为$a_{ij}$的子式。<br>$a_{ij}$的余子式$A_{ij}$为<br>$$ A_{ij} = (-1)^{i+j}det(M_{ij})$$</p><h3 id="行列式-1"><a href="#行列式-1" class="headerlink" title="行列式"></a>行列式</h3><p>$$<br>det(A) = \begin{cases}<br>a_{11} &amp; \text{当n=1时} \\<br>a_{i1}A_{i1}+a_{i2}A_{i2} + \cdots + a_{in}A_{in} &amp; \text{当n &gt; 1时，取第i行} \\<br>a_{1j}A_{1j} + a_{2j}A_{2j} + \cdots + a_{nj}A_{nj} &amp; \text{当n &gt; 1时，取第j列} \\<br>\end{cases}<br>$$<br>矩阵行列式等于矩阵转置的行列式<br>$$<br>det(A) = det(A^T)<br>$$<br>行列式性质</p><ol><li>三角矩阵的行列式等于对角元素的乘积</li><li>若矩阵有一行或一列全为0，则$det(A)=0$</li><li>若矩阵有两行或两列相等，则$det(A)=0$</li></ol><h1 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h1><hr><h3 id="常见的向量空间"><a href="#常见的向量空间" class="headerlink" title="常见的向量空间"></a>常见的向量空间</h3><ol><li>欧几里得向量空间（$R^n$），相同长度和相同方向的向量是相同的；</li><li>向量空间$R^{m*n}$，矩阵空间</li><li>定义在某个区间内的实值连续函数空间，$C[a,b]$，全集为一函数集合</li><li>定义在某个区间内的n阶实值连续可导函数空间，$C^n[a,b]$</li><li>多项式向量空间$P_n$，表示次数小于n的所有多项式集合</li></ol><h3 id="矩阵的零空间"><a href="#矩阵的零空间" class="headerlink" title="矩阵的零空间"></a>矩阵的零空间</h3><p>令$A$为一$m*n$矩阵，矩阵的零空间表示为$N(A)$<br>$$ N(A) = \lbrace x \in R^n | Ax=0 \rbrace $$</p><h3 id="线性组合和张成"><a href="#线性组合和张成" class="headerlink" title="线性组合和张成"></a>线性组合和张成</h3><p>令$v_1, v_2, v_3, \cdots, v_n$为向量空间$V$中的向量，则$a_1v_1 + a_2v_2+\cdots+a_nv_n$称为向量$v_1, v_2, v_3, \cdots, v_n$的线性组合。它们构成的集合称为$v_1, v_2, v_3, \cdots, v_n$的张成，记为$Span(v_1,\cdots,v_n)$.<br>$Span(v_1,\cdots, v_n)$是V的一个子空间。若$Span(v_1,\cdots, v_n) = V$，我们说向量$v_1,\cdots, v_n$张成向量V，${v_1,\cdots, v_n}$是V的一个张集。</p><h3 id="相容线性方程组的解集"><a href="#相容线性方程组的解集" class="headerlink" title="相容线性方程组的解集"></a>相容线性方程组的解集</h3><p>若线性方程组$Ax=b$是相容的，$x_0$为它的一个特解，则向量$y$也为其解的充要条件为$y=x_0+z$，其中$z \in N(A)$.<br>由此我们可以推出求解所有解集的方法：先求出齐次方程的解，然后求一个特解$x_0$，解集即为：$x_0 + a_1z_1 + a_2z_2 + \cdots + a_nz_n$，其中，$z\in N(A)$</p><h3 id="向量线性相关的充要条件"><a href="#向量线性相关的充要条件" class="headerlink" title="向量线性相关的充要条件"></a>向量线性相关的充要条件</h3><p>令$x_1, x_2, \cdots, x_n$ 为$R^n$中的n个向量，并令$X=(x_1, x_2, \cdots, x_n)$.向量$x_1, x_2, \cdots, x_n$线性相关的充要条件是$X$为奇异的。<br>方程$c_1x_1+c_2x_2 + \cdots + c_nx_n = 0$ 可以写成$Xc=0$，若X非奇异，则X存在逆$X^{-1}$，$Xc=0$无非平凡解，即不存在不全为0的$c_1, c_2, \cdots, c_n$，使得该方程成立，表明$x_1, x_2, \cdots, x_n$线性无关。<br>方程$c_1x_1+c_2x_2 + \cdots + c_kx_k = 0$ 中，若k不等于n，即构造的$X$不是方阵，此时不能用X是否奇异来判断线性相关性；此时判别的标准是–$X$的行阶梯型含有自由变量则线性相关。行阶梯型有自由变量表明方程组有非平凡解。</p><h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>当且仅当向量空间$V$中的向量$v_1, v_2, \cdots, v_n$ 满足$v_1, v_2, \cdots, v_n$ 线性无关；$v_1, v_2, \cdots, v_n$ 张成$V$：时，称它们是向量空间$V$的基。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Triple, Angular, ge2e Loss</title>
      <link href="/2019/07/24/Triple-Angular-ge2e-Loss/"/>
      <url>/2019/07/24/Triple-Angular-ge2e-Loss/</url>
      
        <content type="html"><![CDATA[<h2 id="Triple-loss"><a href="#Triple-loss" class="headerlink" title="Triple loss"></a>Triple loss</h2><h3 id="mini-batch-selection"><a href="#mini-batch-selection" class="headerlink" title="mini batch selection"></a>mini batch selection</h3><p>Select <em>M</em> people, each people several items (there is no need to be equal for all people). For example, each batch select 10 person, each person got 20 face images / voice segments.</p><h3 id="generate-triplet"><a href="#generate-triplet" class="headerlink" title="generate triplet"></a>generate triplet</h3><p>Every items will be paired with items from the same people to generate positive pairs. For each positive pair, calculate the distances between the anchor item and items from different owner <code>negative_distances</code>. By subtructing <code>positive_distances</code> (positive pair distance) from <code>negative_distances</code>, we can have all negative pairs that meet our requirement: <code>negative_distance</code> - <code>positive_distance</code> is less than <code>alpha</code>, which means the negative item are too close to anchor item compared with positive item. Then from these negative pairs, select one randomly to generate triplet. Till now, we got a list of triplets: [<code>anchor item</code>, <code>positive item</code>, <code>negative item</code> ]</p><h3 id="calcuate-loss"><a href="#calcuate-loss" class="headerlink" title="calcuate loss"></a>calcuate loss</h3><p>Cossin similarity or Squared distance could be used to calculate the loss.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_triplets</span><span class="params">(embeddings, nrof_images_per_class, image_paths, people_per_batch, alpha)</span>:</span></span><br><span class="line">    <span class="string">""" Select the triplets for training</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    trip_idx = <span class="number">0</span></span><br><span class="line">    emb_start_idx = <span class="number">0</span></span><br><span class="line">    num_trips = <span class="number">0</span></span><br><span class="line">    triplets = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># VGG Face: Choosing good triplets is crucial and should strike a balance between</span></span><br><span class="line">    <span class="comment">#  selecting informative (i.e. challenging) examples and swamping training with examples that</span></span><br><span class="line">    <span class="comment">#  are too hard. This is achieved by extending each pair (a, p) to a triplet (a, p, n) by sampling</span></span><br><span class="line">    <span class="comment">#  the image n at random, but only between the ones that violate the triplet loss margin. The</span></span><br><span class="line">    <span class="comment">#  latter is a form of hard-negative mining, but it is not as aggressive (and much cheaper) than</span></span><br><span class="line">    <span class="comment">#  choosing the maximally violating example, as often done in structured output learning.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(people_per_batch):  <span class="comment"># iterate over each person</span></span><br><span class="line">        nrof_images = int(nrof_images_per_class[i]) <span class="comment"># How many images each person got</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>,nrof_images): <span class="comment"># iterate over all images belonging to the current person</span></span><br><span class="line">            a_idx = emb_start_idx + j - <span class="number">1</span></span><br><span class="line">            neg_dists_sqr = np.sum(np.square(embeddings[a_idx] - embeddings), <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> pair <span class="keyword">in</span> xrange(j, nrof_images): <span class="comment"># For every possible positive pair.</span></span><br><span class="line">                p_idx = emb_start_idx + pair</span><br><span class="line">                pos_dist_sqr = np.sum(np.square(embeddings[a_idx]-embeddings[p_idx]))</span><br><span class="line">                <span class="comment"># exclude positive pairs</span></span><br><span class="line">                neg_dists_sqr[emb_start_idx:emb_start_idx+nrof_images] = np.NaN </span><br><span class="line">            </span><br><span class="line">                all_neg = np.where(neg_dists_sqr-pos_dist_sqr&lt;alpha)[<span class="number">0</span>] <span class="comment"># VGG Face selecction</span></span><br><span class="line">                nrof_random_negs = all_neg.shape[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> nrof_random_negs&gt;<span class="number">0</span>:</span><br><span class="line">                    rnd_idx = np.random.randint(nrof_random_negs)   <span class="comment"># after getting lots of candidates, choose one randomly</span></span><br><span class="line">                    n_idx = all_neg[rnd_idx]</span><br><span class="line">                    triplets.append((image_paths[a_idx], image_paths[p_idx], image_paths[n_idx]))</span><br><span class="line">                    <span class="comment">#print('Triplet %d: (%d, %d, %d), pos_dist=%2.6f, neg_dist=%2.6f (%d, %d, %d, %d, %d)' % </span></span><br><span class="line">                    trip_idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                num_trips += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        emb_start_idx += nrof_images</span><br><span class="line"></span><br><span class="line">    np.random.shuffle(triplets)</span><br><span class="line">    <span class="keyword">return</span> triplets, num_trips, len(triplets)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(y_pred)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    y_pred: [batch_size, embedding_size], it's composed of three parts: </span></span><br><span class="line"><span class="string">            first is the anchors' embeddings, second is the positives' embeddings,</span></span><br><span class="line"><span class="string">            the last is the negative embeddings.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    elements = int(K.int_shape(y_pred)[<span class="number">0</span>] / <span class="number">3</span>)</span><br><span class="line">    anchor = y_pred[<span class="number">0</span>:elements]</span><br><span class="line"></span><br><span class="line">    positive_ex = y_pred[elements:<span class="number">2</span> * elements]</span><br><span class="line"></span><br><span class="line">    negative_ex = y_pred[<span class="number">2</span>*elements:]</span><br><span class="line"></span><br><span class="line">    sap = batch_cosin_similarity(anchor, positive_ex)</span><br><span class="line">    san = batch_cosin_similarity(anchor, negative_ex)</span><br><span class="line">    loss = K.maximum(san-sap+alpha, <span class="number">0.0</span>)</span><br><span class="line">    total_loss = K.sum(loss)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow estimator</title>
      <link href="/2019/07/21/tensorflow-estimator/"/>
      <url>/2019/07/21/tensorflow-estimator/</url>
      
        <content type="html"><![CDATA[<h2 id="Estimator"><a href="#Estimator" class="headerlink" title="Estimator"></a>Estimator</h2><p>A high-level API that simplify training, evaluation, prediction and export for serving. Base class:  <code>tf.estimator.Estimator</code>. It provides the following benefits:</p><ol><li>Scalable (run in local host or distributed env) without modification of the source code;</li><li>Built on <code>tf.keras.layers</code>, which simplifies customization;</li><li>Many tasks handled automatically by Estimator, such as <code>Session</code> &amp; <code>Graph</code>.</li></ol><h2 id="Workflow-of-tensorflow-esitmator"><a href="#Workflow-of-tensorflow-esitmator" class="headerlink" title="Workflow of tensorflow esitmator"></a>Workflow of tensorflow esitmator</h2><p>There are mainly three components for tensorflow estimator: model_fn, input_fn and estimator.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model_fn</span><span class="params">(features, labels, mode)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This function does all the network computation</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    # `features`: input features</span></span><br><span class="line"><span class="string">    # `labels`: labels for responding example</span></span><br><span class="line"><span class="string">    # `mode`: training, evaluation or prediction</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # Return: `tf.estimator.EstimatorSpec`</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `tf.estimator.input.numpy_input_fn</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numpy_input_fn</span><span class="params">(x, y=None, </span></span></span><br><span class="line"><span class="function"><span class="params">                batch_size=<span class="number">128</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                num_epochs=<span class="number">1</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                shuffle=None, </span></span></span><br><span class="line"><span class="function"><span class="params">                queue_capacity=<span class="number">100</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                num_threads=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return: (features, labels). Features is a dict.</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><p>The work flow</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model_fn: </span></span><br><span class="line">image_classifier = tf.estimator.Estimator(model_fn=model_fn, model_dir=model_dir)</span><br><span class="line"></span><br><span class="line">train_input_fn = tf.esitmator.inputs.numpy_input_fn(x=train_data,</span><br><span class="line">                                                    y=train_labels,</span><br><span class="line">                                                    batch_size=<span class="number">64</span>,</span><br><span class="line">                                                    num_epochs=<span class="number">1</span>,</span><br><span class="line">                                                    shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(NUM_EPOCHS):</span><br><span class="line">    image_classifier.train(input_fn=train_input_fn)</span><br></pre></td></tr></table></figure><h2 id="Estimator-1"><a href="#Estimator-1" class="headerlink" title="Estimator"></a>Estimator</h2><p><code>Estimator</code>, <code>model_fn</code>, <code>input_fn</code>是三个主要成分。<br><code>Estimator</code>相当于一个controller，控制在三种不同的情况下(train, predict, evaluation)的工作流。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tf.estimator.Estimator(</span><br><span class="line">    model_fn, </span><br><span class="line">    model_dir=<span class="literal">None</span>, </span><br><span class="line">    config=<span class="literal">None</span>, </span><br><span class="line">    params=<span class="literal">None</span>, </span><br><span class="line">    warm_start_from=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li>model_fn: 见下方</li><li>model_dir： checkpoint路径，如果是已经存在的，则模型会load并restore from the checkpoint.</li><li>config: <code>tf.estimator.RunConfig</code></li><li>params: hyperparameters, type of dict. 如batch_size</li><li>warm_start_from: </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model_fn</span><span class="params">(features, labels, mode, paramas=None, config=None)</span></span></span><br></pre></td></tr></table></figure><ul><li>Features, labels是input_fn的返回值</li><li>mode是<code>train</code>, <code>eval</code> or <code>predict</code></li><li>params: 可以没有该参数；如果有的话，是<code>Estimator</code>中的该参数，用于配置hyperparameters</li><li>config：可以没有该参数；如果有的话，是<code>Estimator</code>中的config参数，Instance of <code>tf.estimator.RunConfig</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tf.estimator.RunConfig(</span><br><span class="line">    model_dir=<span class="literal">None</span>, </span><br><span class="line">    tf_random_seed=<span class="literal">None</span>, </span><br><span class="line">    save_summary_steps=<span class="number">100</span>, </span><br><span class="line">    save_checkpoints_steps=&lt;object object at <span class="number">0x7efe9a76ca80</span>&gt;, </span><br><span class="line">    save_checkpoints_secs=&lt;object object at <span class="number">0x7efe9a76ca80</span>&gt;, </span><br><span class="line">    session_config=<span class="literal">None</span>, </span><br><span class="line">    keep_checkpoint_max=<span class="number">5</span>, </span><br><span class="line">    keep_checkpoint_every_n_hours=<span class="number">10000</span>, </span><br><span class="line">    log_step_count_steps=<span class="number">100</span>, </span><br><span class="line">    train_distribute=<span class="literal">None</span>, </span><br><span class="line">    device_fn=<span class="literal">None</span>, </span><br><span class="line">    protocol=<span class="literal">None</span>, </span><br><span class="line">    eval_distribute=<span class="literal">None</span>, </span><br><span class="line">    experimental_distribute=<span class="literal">None</span>, </span><br><span class="line">    experimental_max_worker_delay_secs=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>跟分布式训练相关的参数都是通过环境变量<code>os.environ[&#39;TF_CONFIG&#39;]</code>来设置的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flask with uwsgi</title>
      <link href="/2019/07/16/Flask-with-uwsgi/"/>
      <url>/2019/07/16/Flask-with-uwsgi/</url>
      
        <content type="html"><![CDATA[<h2 id="Should-we-use-uwsgi-with-Flask"><a href="#Should-we-use-uwsgi-with-Flask" class="headerlink" title="Should we use uwsgi with Flask?"></a>Should we use uwsgi with Flask?</h2><p>Every time when we run a flask app using the internal server, we are prompted to not use that server in production. I believe the warning is based on performance, but what’s the actually differences between using the build-in server and wsgi such as uwsgi? Let’s have a look.</p><p>First, let’s talk about multiple requests handling. Before I write this blog, I thought with the build-in server of flask, it can only handle one request per time. However, when I tested it with Locust, it can handle multiple request very well. The tested API is only a sleep function. So by default, the build in server enable threads to support multiple requests. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># by default, this will enable multi-threads support</span></span><br><span class="line">app.run(host=<span class="string">'0.0.0.0'</span>, debug=<span class="literal">False</span>, port=<span class="number">80</span>)</span><br><span class="line"><span class="comment"># to disable it</span></span><br><span class="line">app.run(host=<span class="string">'0.0.0.0'</span>, debug=<span class="literal">False</span>, port=<span class="number">80</span>, threaded=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># note: when debug is True, any modification of the app will make the app get reloaded.</span></span><br></pre></td></tr></table></figure><p>So if our API is something like <code>sleep</code> fuction, only using the build-in server can satisfy us. However, in reality, most API will both have cpu-consuming tasks and io-waiting tasks.<br>Thus in theory, assigning multiple requests to one flask app (with multiple threads) can not take advantage of multiple cores due to python’s global GIL (global interprete lock).</p><h2 id="The-advantage-of-using-uwsgi"><a href="#The-advantage-of-using-uwsgi" class="headerlink" title="The advantage of using uwsgi"></a>The advantage of using uwsgi</h2><blockquote><ol><li>It can scale your APP automatically. </li></ol></blockquote><p>With uwsgi, you can set the minimum and maximum number of works to handle requests. When too many requests come in simultaneously, uwsgi would spawn extra processes to process these requests.</p><blockquote><ol start="2"><li>With Uwsgi, you can take advantages of multiple cores.</li></ol></blockquote><p>If your app is computation heavy tasks (cpu intensive tasks) and you do not enable threads supporting in uwsgi configuration, each request will be processing in seperate process. </p><h2 id="Using-uwsgi-compared-with-multi-APP-instances"><a href="#Using-uwsgi-compared-with-multi-APP-instances" class="headerlink" title="Using uwsgi compared with multi APP instances"></a>Using uwsgi compared with multi APP instances</h2><p>By saying Multi app instances, I mean running multiple APP in different IP/Ports and using Nginx for load balancer. Running Multiple Apps has several constraints:</p><ol><li>You have to decide how many instances to run. It cannot scale automatically.</li><li>With <code>threaded support</code>, you are risking of handling multple requests in the same processes. This will compromise the performance. Without <code>threaded support</code>, you may have a longer response time since the next request won’t be processing until the current one finished. The largest number of requests you can handle simultaneously won’t be greater than the number of app instances.</li></ol><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>The best way to verify a theory is by testing. </p><h3 id="Test-with-IO-heavy-task-threads-enabled"><a href="#Test-with-IO-heavy-task-threads-enabled" class="headerlink" title="Test with IO heavy task (threads enabled)"></a>Test with IO heavy task (threads enabled)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># sleep for two seconds</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello world from flask"</span></span><br></pre></td></tr></table></figure><p>Then use <code>Locust</code> for testing. User number is 20, waiting time is 0.</p><p><img src="/images/flask_with_uwsgi/multi_flask_in_different_ports.png" alt="upstream" title="running multiple app and load balancing them with nginx "><br><img src="/images/flask_with_uwsgi/uwsgi_with_threads_supported.png" alt="upstream" title="uwsgi with threads enabled"></p><h3 id="Test-with-CPU-intensive-task-threads-enabled"><a href="#Test-with-CPU-intensive-task-threads-enabled" class="headerlink" title="Test with CPU intensive task (threads enabled)"></a>Test with CPU intensive task (threads enabled)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.random((<span class="number">40000</span>, <span class="number">3000</span>))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"create a shape of (40000, 3000) numpy array"</span></span><br></pre></td></tr></table></figure><p>NOTE: the average time cost for this function is <code>11000 ms</code> in this specific settings.</p><p>Then use <code>Locust</code> for test. User number is 10, waiting time is 0.</p><p><img src="/images/flask_with_uwsgi/multi_flask_in_3_ports_with_threads_enabled.png" alt="upstream" title="running three instance with threads enabled"></p><p><img src="/images/flask_with_uwsgi/uwsgi_threads_disabled_cpu_intensive_task.png" alt="upstream" title="uwsgi with threads disabled"></p><h2 id="Additional-settings"><a href="#Additional-settings" class="headerlink" title="Additional settings"></a>Additional settings</h2><h3 id="nginx-load-balancing"><a href="#nginx-load-balancing" class="headerlink" title="nginx load balancing"></a>nginx load balancing</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">0.0.0.0:81</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">0.0.0.0:82</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">0.0.0.0:83</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uwsgi-configuration"><a href="#uwsgi-configuration" class="headerlink" title="uwsgi configuration"></a>uwsgi configuration</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">module = main</span><br><span class="line">callable = app</span><br><span class="line"># the minimum number of workers to keep all the time</span><br><span class="line">cheaper = 2</span><br><span class="line"># the maximum number of workers to spawn</span><br><span class="line">workers = 20</span><br><span class="line"># enable threads and set the threads as 5</span><br><span class="line">threads = 5</span><br><span class="line"></span><br><span class="line">socket = /tmp/uwsgi.sock</span><br><span class="line">chown-socket = nginx:nginx</span><br><span class="line">chmod-socket = 664</span><br><span class="line">hook-master-start = unix_signal:15 gracefuulay_kill_them_all</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PCA VS. LDA</title>
      <link href="/2019/07/05/PCA-VS-LDA/"/>
      <url>/2019/07/05/PCA-VS-LDA/</url>
      
        <content type="html"><![CDATA[<h2 id="What’s-PCA"><a href="#What’s-PCA" class="headerlink" title="What’s PCA?"></a>What’s PCA?</h2><p>Principal Component Analysis is to maximize variance of dataset. It’s based on the idea that some features may be more important/diversified than others. </p><ol><li>PCA is a unsupervised algorithm, while LDA is supervised.</li></ol><h2 id="How-to-use-them"><a href="#How-to-use-them" class="headerlink" title="How to use them?"></a>How to use them?</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">feature_reduced = pca.fit(X).transform(X)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> LDA</span><br><span class="line">lda = LDA(n_components=<span class="number">2</span>)</span><br><span class="line">feature_reduced = lda.fit(X).transform(X)</span><br></pre></td></tr></table></figure><p><a href="https://sebastianraschka.com/faq/docs/lda-vs-pca.html" target="_blank" rel="noopener">reference</a><br><a href="http://www.vfirst.com/blog/techfirst/dimension-reduction-techniques-pca-vs-lda-in-machine-learning-part-2/" target="_blank" rel="noopener">reference2</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bert</title>
      <link href="/2019/06/26/bert/"/>
      <url>/2019/06/26/bert/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-bert"><a href="#What-is-bert" class="headerlink" title="What is bert?"></a>What is <code>bert</code>?</h2><p><img src="/images/bert/figure1.png" alt></p><h2 id="Bert-training"><a href="#Bert-training" class="headerlink" title="Bert training"></a>Bert training</h2><p>The rough process of training Bert is like: randomly mask some words in a sentence, then</p><h2 id="Data-preparation"><a href="#Data-preparation" class="headerlink" title="Data preparation"></a>Data preparation</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>Collect Corpus and arrange them by rules: one sentence per line and Each document are separated by a blank line.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Bidirectional Encoder Representations from Transformers (BERT) has shown marvelous improvements across various NLP tasks. </span><br><span class="line">Recently, an upgraded version of BERT has been released with Whole Word Masking (WWM), which mitigate the drawbacks of masking partial WordPiece tokens in pre-training BERT. </span><br><span class="line">In this technical report, we adapt whole word masking in Chinese text, that masking the whole word instead of masking Chinese characters, which could bring another challenge in Masked Language Model (MLM) pre-training task. </span><br><span class="line">The model was trained on the latest Chinese Wikipedia dump. </span><br><span class="line"></span><br><span class="line">We aim to provide easy extensibility and better performance for Chinese BERT without changing any neural architecture or even hyper-parameters. </span><br><span class="line">The model is verified on various NLP tasks, across sentence-level to document-level, including sentiment classification (ChnSentiCorp, Sina Weibo), named entity recognition (People Daily, MSRA-NER), natural language inference (XNLI), sentence pair matching (LCQMC, BQ Corpus), and machine reading comprehension (CMRC 2018, DRCD, CAIL RC). </span><br><span class="line">Experimental results on these datasets show that the whole word masking could bring another significant gain. Moreover, we also examine the effectiveness of Chinese pre-trained models: BERT, ERNIE, BERT-wwm.</span><br></pre></td></tr></table></figure><h2 id="Source-Code-Anatomy"><a href="#Source-Code-Anatomy" class="headerlink" title="Source Code Anatomy"></a>Source Code Anatomy</h2><h3 id="TrainingInstance"><a href="#TrainingInstance" class="headerlink" title="TrainingInstance"></a><code>TrainingInstance</code></h3><p><code>tokens</code>: tokens (words) after being masked<br><code>segment_ids</code>: [0,0,0,0,1,1,1]<br><code>is_random_next</code>: If the second segment is the next sentence of the first one<br><code>masked_lm_positions</code>: [5, 10, 34, 63], masked tokens’ index<br><code>masked_lm_labels</code>: [‘we’, ‘some’, ‘body’, ‘good’], the acctual token befor being replaced.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search Tree</title>
      <link href="/2019/06/18/Binary-Search-Tree/"/>
      <url>/2019/06/18/Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h2 id="level-first-order-breadth-first-order-print-tree"><a href="#level-first-order-breadth-first-order-print-tree" class="headerlink" title="level first order/breadth first order print tree"></a>level first order/breadth first order print tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_tree</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="comment"># use a FIFO queue to store trees to be printed</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="literal">None</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">'null'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Print the value the current tree and put its children to queue</span></span><br><span class="line">            print(root.val, end=<span class="string">'\t'</span>)</span><br><span class="line">            stack.append(root.left)</span><br><span class="line">            stack.append(root.right)</span><br><span class="line">        <span class="comment"># Each time get a TreeNode from the front of the queue </span></span><br><span class="line">        root = stack.pop(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h2 id="inorder-traversal-of-BST"><a href="#inorder-traversal-of-BST" class="headerlink" title="inorder traversal of BST"></a>inorder traversal of BST</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="string">""" using stack """</span></span><br><span class="line"></span><br><span class="line">    final = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append((root.val, root.right))</span><br><span class="line">            root = root.left</span><br><span class="line"></span><br><span class="line">        val, right = stack.pop()</span><br><span class="line">        final.append(val)</span><br><span class="line">        root = right</span><br><span class="line">    <span class="keyword">return</span> final</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_inorder_traverse</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="string">"""In-Place method, Morris traversal</span></span><br><span class="line"><span class="string">    Notice this method can not format a new flatten TreeNode in inorder-traversal.</span></span><br><span class="line"><span class="string">    Although it can produce values in inorder-traversal.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cur = root</span><br><span class="line">    final = []</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">            final.add(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = cur.left</span><br><span class="line">            <span class="keyword">while</span> pre.right:</span><br><span class="line">                pre = pre.right</span><br><span class="line">            pre.right = cur</span><br><span class="line">            temp = cur</span><br><span class="line">            cur = cur.left</span><br><span class="line">            temp.left = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> final</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder_recursive</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="string">"""Recursive method"""</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> inorder_recursive(root.left) + [root.val] + inorder_recursive(root.right)</span><br></pre></td></tr></table></figure><h2 id="preorder-traversal-of-BST"><a href="#preorder-traversal-of-BST" class="headerlink" title="preorder traversal of BST"></a>preorder traversal of BST</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="string">"""Morris"""</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = cur.left</span><br><span class="line">            <span class="keyword">while</span> pre <span class="keyword">and</span> pre.right:</span><br><span class="line">                pre = pre.right</span><br><span class="line">            pre.right = cur.right</span><br><span class="line">            tmp = cur</span><br><span class="line">            cur = cur.left</span><br><span class="line">            tmp.right = cur</span><br><span class="line">            tmp.left = <span class="literal">None</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_stack</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="string">"""With stack"""</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">and</span> root.left:</span><br><span class="line">            tmp = root</span><br><span class="line">            root = root.left</span><br><span class="line">            <span class="keyword">if</span> tmp.right:</span><br><span class="line">                stack.append(tmp.right)</span><br><span class="line">            tmp.right = root</span><br><span class="line">            tmp.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            stack.append(root.right)</span><br><span class="line">            root.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = stack.pop()</span><br><span class="line">            root.right = right</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pre = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_recursive</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="string">"""Smart recursive"""</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    preorder_recursive(root.right)</span><br><span class="line">    preorder_recursive(root.left)</span><br><span class="line">    root.right = pre</span><br><span class="line">    root.left = <span class="literal">None</span></span><br><span class="line">    pre = root</span><br></pre></td></tr></table></figure><h2 id="postorder-traversal"><a href="#postorder-traversal" class="headerlink" title="postorder traversal"></a>postorder traversal</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder_traversal</span><span class="params">(root: TreeNode)</span> -&gt; [int]:</span></span><br><span class="line">    <span class="string">"""with stack"""</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack = [(root, <span class="literal">False</span>)]</span><br><span class="line">    final = []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, visited = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                final.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append((node, <span class="literal">True</span>))</span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">    <span class="keyword">return</span> final</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_pre</span><span class="params">(root: TreeNode)</span> -&gt; [int]:</span></span><br><span class="line">    <span class="string">"""Modified preorder traversal, then reverse the result"""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack = []</span><br><span class="line">    final = []</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            final.append(cur.val)</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        cur = stack.pop().left</span><br><span class="line">    final.reverse()</span><br><span class="line">    <span class="keyword">return</span> final</span><br></pre></td></tr></table></figure><h2 id="Traversal-Summary"><a href="#Traversal-Summary" class="headerlink" title="Traversal Summary"></a>Traversal Summary</h2><blockquote><p>Only preorder traversal can happen in place, namely forming a new <code>LinkedList</code> without using extra space. ???</p></blockquote><h2 id="unique-BST"><a href="#unique-BST" class="headerlink" title="unique BST"></a>unique BST</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_tree</span><span class="params">(start, end)</span> -&gt; [TreeNode]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> start == end:</span><br><span class="line">        <span class="keyword">return</span> [TreeNode(start)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    final = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(end-start+<span class="number">1</span>):</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> gen_tree(start, start+i<span class="number">-1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> gen_tree(start+i+<span class="number">1</span>, end):</span><br><span class="line">                this = TreeNode(start+i)</span><br><span class="line">                this.left = left</span><br><span class="line">                this.right = right</span><br><span class="line">                final.append(this)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> final</span><br></pre></td></tr></table></figure><h2 id="permutation"><a href="#permutation" class="headerlink" title="permutation"></a>permutation</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(n)</span>:</span></span><br><span class="line"></span><br><span class="line">    res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            remain = i<span class="number">-1</span>-j</span><br><span class="line">            res[i] += res[j] * res[remain]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BST </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/17/hello-world/"/>
      <url>/2019/06/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cossim_my</span><span class="params">(embeddings)</span>:</span></span><br><span class="line">    b, n, v = embeddings.shape</span><br><span class="line">    left = embeddings.repeat(<span class="number">1</span>, <span class="number">1</span>, embeddings.size(<span class="number">0</span>)).view(b, n, b, v)</span><br><span class="line">    centroids = embeddings.mean(dim=<span class="number">1</span>)</span><br><span class="line">    right = centroids.repeat(b, n, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    s = embeddings.sum(dim=<span class="number">-2</span>, keepdim=<span class="literal">True</span>) - embeddings</span><br><span class="line">    s = s / (embeddings.shape[<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> b_idx <span class="keyword">in</span> range(b):</span><br><span class="line">        <span class="keyword">for</span> utt_idx <span class="keyword">in</span> range(n):</span><br><span class="line">            right[b_idx][utt_idx][b_idx] = s[b_idx][utt_idx]</span><br><span class="line">    sim = F.cosine_similarity(left, right, dim=<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> sim</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DL </category>
          
          <category> LSTM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ge2e </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
